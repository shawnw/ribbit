(* RVM code that prints HELLO! *)
let input = "R3rotanimoned,2/be,rddaac,?>rahc,trats-tni-llac,trats-teg,nim,ypoc-gnirts,?evitagen,dmc-llehs,dna,sedoc>-gnirts,po-tes,dnuor,nigeb,!tes,fi,!tes-gnirts,liat,fer-rav-labolg,slobmys-denretninu,rddddc,mcl,yllamron-margorp-tixe,po-tsnoc,trats-tes,margorp-daer,tropxe,htgnel-rotcev,tsnoc,tes,_,trats-corp-tsnoc,?orez,tel,trats-mys-llac,rdaaac,yllamronba-margorp-tixe,rahc-etirw,po-fi,trohs-mys-llac,?=<gnirts,trats-tni-teg,?evitisop,radaac,dnapxe-dnoc,etouq,gniliec,?=>rahc,!tes-rav-labolg,dnoc,!llif-rotcev,rdaddc,raaaac,?=>gnirts,tibbir,?=<rahc,enifed,ro,trats-tni-tes,trats-mys-tsnoc,rddadc,trats-tni-tsnoc,trats-tni-pmuj,rts-ot-tuptuo-htiw,certel,radadc,etacnurt,edoc-tegrat-etirw,trats-mys-pmuj,po-teg,teg,po-llac/pmuj,trats-mys-teg,raaddc,vne-erudecorp,*tel,fer-rotcev,xam,radddc,roolf,llac/pmuj,trats-mys-tes,trats-fi,rdaadc,!llif-gnirts,?tsil,rdadac,trats-llac,trats-tsnoc,rotaremun,reffub,adbmal,!tes-rotcev,lbtmys,esle,stropxe-xtc,qmem,?naeloob,raddac,gnirts-ekam,?<rahc,raaadc,rotcev-ekam,elif-led,oludom,raadac,vssa,>,elif-morf-tupni-htiw,tsil>-elbat,elif-tupni-htiw-llac,sisylana-ssenevil,sfed-teser,enil-daer,lobmys-denretninu>-gnirts,elif-tpircs,redniamer,!tes-evil-xtc,dcg,?=rahc,?neve,?<gnirts,llac-dna-dniwnu,yrarbil-daer,!tros-tsil,edocne,stropxe-tcartxe,rahcteg,cc/llac,?ddo,=<,elipmoc,htap-elbatucexe,gnirts-ot-tuptuo-htiw,?>gnirts,tros-tsil,enil-dmc,ssenevil,noisnetxe-htap-csr,edoc-etareneg,elif-ot-tuptuo-htiw,margorp-elipmoc,tpxe,dnibnu-neg,lave,?qe,relipmoc-enilepip,htgnel-elbat,rebmun>-gnirts,xua-esrever,*,?tnatsnoc,radc,?=gnirts,tsil-etirw,rahc>-regetni,xua-?tsil,tnemmoc-piks,?ni,gnirts>-lobmys,elbat-ekam,xua-rebmun>-gnirts,!tes-elbat,repo,xua-rahc-daer,fer-tsil,*dnib-pmoc,raaac,xua-gnirtsbus,raddc,yrotcerid-htap-csr,raac,tsila>-stropxe,xua-lobmys>-gnirts,rdadc,rdaac,stropxe-htiw-srpxe-pmoc,2xua-rebmun>-gnirts,!tes-tsil,lper,raadc,tsil-dnapxe,tixe,tsil-daer,xua-sisylana-ssenevil,?tsil-rahc,xtc-ekam,xua-tsil-ekam,rebmem,edoc-erudecorp,radac,evil>-stropxe,lla-daer,tneitouq%,elif-morf-gnirts,?2erudecorp,!rac-tes,rotcev>-tsil,3tsil,lobmys>-gnirts,tnatsnoc-dnapxe,enilwen,nigeb-dnapxe,lobmys-esu,ydob-dnapxe,elif-morf-daer,liat-tsil,evil-xtc,xua-dcg,1tsil,hcae-rof,lave-dnapxe-dnoc,pmc-gnirts,xua-gnirts>-rebmun,2tsil,xua-pmc-gnirts,!tes-2dleif,rdddc,lobmys-denretninu>-rts,poon-neg,tsil>-rotcev,sba,lobmys-daer,regetni>-rahc,gnirts>-rebmun,cossa,gnirtsbus,ngissa-neg,ecapsetihw-non-rahc-keep,fer-elbat,tes-etc-xtc,enod-ydob-dnapxe,?erudecorp,?ecnatsni,tsil-ekam,llac-pmoc,llac-neg,rdddac,?tcejbo-foe,2rahctup,srahc-daer,daer,etanetacnoc-gnirts,rts>-lobmys,pp,?evil,sesualc-dnapxe-dnoc-dnapxe,dnib-pmoc,*nigeb-dnapxe,rahc-keep,erudecorp-ekam,+%,fer-gnirts,fi-dliub,dnetxe,etirw,dnpo,tneitouq,gnirts>-maerts,!tes-1dleif,etc-xtc,?rotcev,qssa,txen,?llun,!rdc-tes,pukool,srahc-etirw,?bir,evil-dda,nigeb-pmoc,=>,esrever,rorre,?gnirts,htgnel-gnirts,dneppa,vmem,?regetni,=,rddac,gnirts>-tsil,xeh-daer,-,!tes-0dleif,tsil>-gnirts,htgnel,?lobmys,0dleif,rahctup,*%,2dleif,1dleif,<,rpxe-dnapxe,<%,yalpsid,ecalper-gnirts,setyb-ot-edoc-mvr,hguorht-epip,pam,?lauqe,rid-toor,dnapxe-htap,rahc-daer,rorre-epyt,rddc,-%,pmoc,ton,+,rdac,esolc,dneppa-gnirts,?riap,rac,1gra,?vqe,2gra,rdc,snoc,di,lin,eurt,eslaf,bir;8TL!TL8@YU%YU#YSLki$i$kiX8y!V?8U$G8@by^8@_~RiY%^{!?7&i&kkA^[$G9HiX(Z*?aYS*Z\'h-_f7$YMlfA^[$G7/fIldb7\'YMl^~YU9Z>`h1Z>I`dh/70??h.YS*h.gh3h4_^Ih/c~YCk^zi$~YU.Z\'gIf_|i$Z\'aZ\'_|!>9H`SYK_G8S,YS-^z{!U%\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCi$\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCWiY6CWZ\'^CWiX-~Z+ldFiX9\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCi$\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCWiY6CWZ\'^CWiX-~Z+ldFYSJe~e_YSJPQFFFdiX+biX>\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCi$\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCWiY6CWZ\'^CWiX-~Z+ldFiX9\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCi$\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^JgAViX=iX2VUiY7aUiY+_VUiX4aUiY,_Va_`iXA\'^T_PQFFiY-eiX/\'^^~ARiXNe\'^T_PQFFiY-eiX/\'^^~A^~^Jg^~RiY(cCWiY6CWZ\'^CWiX-~Z+ldFYSJe~e_iXP~RiXJaYU3__@cDb}(!SJ8UBG8U?i$^z^z!W;9&YS?`9&YSL~RiXB`YU5^{!U58S?^8S?PPQiY)FiXK^~RiY#YU&^z!S?8UDiSL^z!SL(YSL^\'i&~ZL^ZIy!:8T4AYU,8T4A^~^YU=y!WJ8<YK_iS-z]88OS_G8TC^8TCvD~Z#vS#^IvF^zz!U37&i&`kA^[$G7&ca_A^[$G7&cg_A^[$G7$aA^[$G/FFZ8aiY2ZHiY0SaG8OZ*YK^ZG^zZ8XBi&YMYJ`YJeX?i&hR%7\'@^~i$/FFZ8aiY2ZHiY0SaG8OZ*YK^ZG^zZ8XBi&YMYJ`YJeX?i&hR%7\'@^~YTEiY&ZGD^~E^zi$70?h-a@eIlcCYLd^@aYS2iX*7.e@ca~^Z4hR%^D^D_~E_|i$7.e@ca70?h-a@eIlcCYLd^@a@^~^Z4hM^D^D_~E_|i$70?h-`@eIlcCYLd`YS2iXL70?h-`@eIlcCYLd`@^~^Z4hH_@_D^D_~i$7&ca_A^[$G7&cg_A^[$G7$aA^[$G/FFZ8aiY2ZHiY0SaG8OZ*YK^ZG^zZ8XBi&YMYJ`YJeX?i&hR%7\'@^~i$/FFZ8aiY2ZHiY0SaG8OZ*YK^ZG^zZ8XBi&YMYJ`YJeX?i&hR%7\'@^~YTEiY&ZGD^~E^zi$70?h-a@eIlcCYLd^@aYS2iX*7.e@ca~^Z4hR%^D^D_~E_|i$7.e@ca70?h-a@eIlcCYLd^@a@^~^Z4hM^D^D_~E_|i$70?h-`@eIlcCYLd`YS2iXL70?h-`@eIlcCYLd`@^~^Z4hH_@_D^D_~YCiW-^~E_|i$YU)YUCh<G8CX)_X(_{CX5h<CX1h<CYS:iXDG74n^z[$G8H^@`2YJ_vS[rz0~^YSPiXD^D^z[%G9)i&iX09)_iY\'7+X,?ciV0Z:`Z3_~BiW.^7+AZ)_iX:7+AX/c^~YSI^7+AX3dX4_iVG~YI^7+AX4d_iVE7+A?cI_iV*~YCv.^~X-^Z:`Z3_~BiW=^7+AZ)_iY.7+AX3dX4_iV:~YI^7+AX4d_iW+7+A?cI_iWP~YCu^~X-^Z:`Z3_~BiV=^7+AZ)_iX37+AX3dX4_iV1~YI^7+AX4d_iVH~X-^Z:`Z3_~BiWI^7+AZ)_iY37+AAX4e_iW27+AA?dI_iV+~YCiW-^X3^~YI^7+AX4d_iX#~X-^Z:`Z3_9)_iXO73d_iV>(cI_k~YCv7^X2^~YI^73c_iVD~X,^Z:_~BZ3`k~BiV;^YT;^~Z.^{[&G9$^z[\'G7,X4d`IoiW57,?cI`iW5~YCo_Z3_YH^YSO^{[(G72e_`\'^~Z#k`?bIiX&^72e_`\'^~Z#k`?b^~BcaYMYTHiX&__Z9iX&^|[)G7.a`^{[*G(``(@`Il`~Z#IliX&^D^X/a_|[+G(X0b`^|[,G8H^YS\'i$_h>z[-G\'i$76n^~BiWI_77l^CZ7_aCYLiV=aX8^76m^~AAi$77l^CZ7_aCYLiV=aX8^76m^~AAZ+k`~X-`77l^CZ7_aCYLiV=aX8^76m^~AA^~^YSI_77l^CZ7_aCYLiV=aX8^76m^~A^~^YI^~BiW=_76l^~BiV=_76k^~BiV;_73^~BiW._Z:_YT;^z[.G\'i$71Z3^CX0^~Z.^z[/G\'i$75^~YSI^\'i$8S4IYE`l^~Z#m`97IYD`l^~Z#l`8LIYH`l^~Z#k`AA^CYT<`ahA:kkk\'i$8S4IYE`l^~Z#m`97IYD`l^~Z#l`8LIYH`l^~Z#k`A^~^YS\'i$_h?~YI^{[0G\'^CX4`^{[1G71Z3YSO^z[2G\'^CX4k^z[3G\'^CX6n^CX?_`[9Ilh8YSEFYS,h8iX<1^~^Z4h>^\'w&~Bi&^\'w%~Bi%^\'w$~Bi$^z[4k[5G8S4X=X;YE_^YH^z[6G7%`h>A^[$G\'_7-XE:gbiWI_@bM`H_D^D^~E^{i$z[7G#X>bYE`YD_YH^\'_~Bk^{[8G7%a@iY4A^[$G\'_7)AAb7)AAX-c_~i$7)AAb7)AAX-c_~AAYCYEak7)AAb7)AAX-c_~AA^~^YCYD`k7)AAb7)AAX-c_~A^~^YCYH_k~^YS\'i$_hFDD_@^~E^{i$[$G#::::h.XBngiWIX@kw#iV;liW=kiW=HZ4iY4_iW={i$z[9G\'`[@?h@??`a_X?k^{[:G9)_iXE7@XA::fX;kw#iV;oiW=YJ_^YS0^~Z5^7@XA::fX;kw#iV;niW=YJ_^SYK_iS-~Z(^7?X@::eX:kw#iV;kiW=@_D^~E^#a_iW=#::eX:kwMiV;YMbkiW=kiW=~YCk^~X*^#aX6m_iW=~YI^#bX7l_iV=X7^~AZ4h@_9)_iXE7@XA::fX;kw#iV;oiW=YJ_^YS0^~Z5^7@XA::fX;kw#iV;niW=YJ_^SYK_iS-~Z(^7?X@::eX:kw#iV;kiW=@_D^~E^#a_iW=#::eX:kwMiV;YMbkiW=kiW=~YCk^~X*^#aX6m_iW=~YI^#bX7l_iV=X7^~A^~^Z%iXH^{[;i&[<YT>i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i${!V0IIloiW5!W5ImiVG!VGIliVE!VEIv.iV*!V*ImiV:!V:IliW+!W+IuiWP!WPImiV1!V1IliVH!VHIkiW<!W<ImiW2!W2IliX#!X#IiW-iV+!V+ImiV>!V>IliVD!VDIv7k!W-YMIIIIv4v7uov.vS#!X&Z9mvS#!U\'\'cCX\'i%i&b[$G\'i$7)`@^CX+i$`D^~E^{[%G\'i$7+a_7.i$Z<c_YP`H_~BwV\'^7+a@_~BwWG^7.i$Z&cS`i-YP`CX,bS_i1H_~BwW3^7-i$aZM_CX-i$aYP_CX-i$aH_~BwWE^\'i$70i$d_CZ1?@``^~^ZEh1_Ci$\'i$70i$d_CZ1?@``^~^ZEh1_CX/_~h17/i$c^~YT@c_YP`H_~BwWF^7-^H_~BwW\'^D^~E^7,^\'i$~YT@`^~YI^|[&G\'i$8S:YS0_c~Z5^7)@^CX)D^~E^7*^~YI^z[\'G\'k[,Z-g^zi$i$i$i$|!T@3BZ0ka_^{!TG\'i$\'i$\'i$+DH_wW\'~EH^~Z2M^~E@^z]E\'i$9E@a_\'^~BD__D_~E_{]-(a^?i&^\'_~ZE`^{!U@7$_A^[$G\'i$7\'@^CZ1i&D^~E^zi$z!SM\'i&(YSM@_?i&DD^~E^z!T&7$Z-Z-Z-Z-YSMAi&7$Z-Z-Z-Z-YSMA^~^dw\'w0w*w,A^[$G7(^\'_~B`^YU\'Je_bCYU@^zi${!UA\'^8T&a_~YS+_wV%YT&i&^{!T)\'i&(YT)@_YBD^~E^z]D\'_9Da@_9Ba@^~AYS9D_9Da@_9Ba@^~A^~^BD_wV$D^~E^{!S9+wVL^3JZ%S@`iS9i%~i$+wVL^3JZ%S@`iS9i%~BwVID^~E^3Z%S@`iS9i$~i$+wVL^3JZ%S@`iS9i%~i$+wVL^3JZ%S@`iS9i%~BwVID^~E^3Z%S@`iS9i$~BwWKD^~E^3YS9H^~i$+wVL^3JZ%S@`iS9i%~i$+wVL^3JZ%S@`iS9i%~BwVID^~E^3Z%S@`iS9i$~i$+wVL^3JZ%S@`iS9i%~i$+wVL^3JZ%S@`iS9i%~BwVID^~E^3Z%S@`iS9i$~BwWKD^~E^3YS9H^~Bw3D^~E^z]B\'_(_YB_9D_@_~i$(_YB_9D_@_~BwW(D_~E_9B_@_~i$(_YB_9D_@_~i$(_YB_9D_@_~BwW(D_~E_9B_@_~BwWGD_~E_ZBa@_D^~E^{!SB8SDk-^(_wWG~E@^~E^ZBi&^z!S%8SB_8B??aZ*_wVB~E^{!S@7%i&_A^[$G8S%iX1_8S%``7+?c?Ma_@`7+?c??i&??Mc@awV\'D_@`~E^H^~i$8S%``7+?c?Ma_@`7+?c??i&??Mc@awV\'D_@`~E^H^~i$8S%``7+?c?Ma_@`7+?c??i&??Mc@awV\'D_@`~E^H^~E@^~BD_wVJ~E^D^~E^{i$z!SD(?i&_wW\'z!B8SD^8T)_8Bi$8B????i&?McwW#?@HbwWGDH`wWE8B?@H`wWG~BDH`wV$~E@_~BwW#^8Bi$8BH_8B???i&????i&?MewVIwW6wW6wWE?i&??i&HawW6wW3~EM_~E@_~BwVI^8Bi%8BH_8B????i&i$?MbwWKH`wWE~EM_~E@_~BwWK^(??i&YBYPb_wWF(??i&YB??Md@awV\'D_wWF~E^H_~BwVJ^8SB@_~BwWG^8B??Z&McSaG(??i&H`D_wWFzS`G(?i&i$D^zwW3H_~BwVB^8B?@a8B???i&??Md@awV7?i&D_~i$8B?@a8B???i&??Md@awV7?i&D_~E@_~E_wW3H_~BwV7^8S@Ma(??i&YS@McS`G(?i&YBH_D^zwW3~E^^8BA?S`i1???i&a?i&??i&??YS3eSbi-wV\'`wVBYP`~YI^H_~BwW3^(??i&YS@Mb_wV\'H_~BwV\'^(???i&i$(???i&YBZMb~EYS3bYBYPaYBH`wWE~BwWE^(??i&YBYPb_wWFH_~BwWF^8SDH_~BwW\'^D^~E^\'^~YI^z!U#\'^Ci$\'^CZF@^CWiXC~Z+nbCi$\'^Ci$\'^CZF@^CWiXC~Z+nbCZFD^CWiXI~Z+mbYT.YT2_?i&i$\'^Ci$\'^CZF@^CWiXC~Z+nbCi$\'^Ci$\'^CZF@^CWiXC~Z+nbCZFD^CWiXI~Z+mbYT.YT2__~E_@_D^YU2_{!T.(ASaG(_^D^z(A^~^bZ@i&:KiWCbYT$Ai&(ASaG(_^D^z(A^~^bZ@i&:KiWCbYT$A^~^eai&kkYUAa^YSB^{!T2\'^8<_G(H_D^(_^~YI^z~E^z!U27&i$i&_A^[$G(aZ*_7,c?b_@_7,Z&Ai&7,Z&A^~^d@`a@_~i$7,c?b_@_7,Z&Ai&7,Z&A^~^d@`a@_~BwW:D^~E^D^~E^|i$z!WC:kw\'iV;]<\'_(Z<a@_D^~E^{]0\'^90Ilb@`^\'`~B_D_~E_|]O7&^4ZOd@bYS&?Z6bi$`D`^~E_|],4b4:Z,f@dbYSAw,aiV;~E@aD`^|!SA\'_CYU;Z-YS=``^{!TO#aYSAw*_iV;\'_~BiWC_{!T89,eca4YT8YTOh2gh/YS&?Z6h/eh-@f@dYS&?Z6di$b_`DaD_~E_})]C8T8geab`^}(!S1#`kiW=8E^~i$#`kiW=8E^~i$#`kiW=8E^~i$#`kiW=8E^~Z.YE^~Bw,YD^~BiV;YH^~Z.^z!S)#YS1a_iWI{]N#a_iV;#k_iV;~BiWC_{!4#b`iW=9Cf?i&?bwW6?i&aiX7`9OG9Nh.^Z0kZ6_dz_`~YI_@`9CgaSbi1Sai-aMaH`~BwW3^9,c@a_~BwWG^#ZNeYSAw0b#d~Z2Z6bZ@i&:Z,iWCMeYS&Z<??Z6gi$i$bckYJ_iW=H`~BwV\'^4`Hdb:a_iW.KdYPb`KcZMa_~BwWE^4YS)g``b8S1e4YS)h-aac8S1e~YTG^~^ZEYS=c`~Ba^Z0lZ6b_YPaH`~BwWF^#cHaiW=~BwW\'^D_~E_#d`iV=#dHH_iW=~i$#d`iV=#dHH_iW=~YTG^~^ZEYS=``Z0kZ6__~YI_|!U;8SH`YD^{!S&#YE`YD__{!V#8E^z!S=-YD^z]68H^z!T$#b?i&`^|]38E^z]:8D^z!T;8H^z!SIiS$!W.wWE!W=wW8!V=wV<!WIwW7!V;wV2]H\'iY$7%YKDa@`A^[$G8O_7)Z&Z&beYKD_@^~E^{i$YK`Z*^~E^{!U,\'iY/y!U=-YU(y!U)8U4Z&i&`^{!U47(_c\'i&~Z#_kYJb[$G\'^CZ1b_\'^CZ1a_7/f@dc`CZ1ca7/@fdd`CZ1da~X0`^DbD`~Ea~E`}\'[%G\'_\'^7-d@ba`7-@dbba~X.`^D`D^~E_~E^{[&G7%a_A^[$G71_X2eeX1YMef_7)@`YMl^~YUEk^{i$Z9m_\'^CZ1i&^~Z#l_{i$i$i${]F8SCCZ;^z!U?7$i&A^[$G7(?`^8OZ*_~ABf_7(?`^8OZ*_~A^~^ZL^Obzi${!9/F`iX?_/__~Z#vR$YS-Z>YMlZ\'`_\'^~Z#kZ\'_{!T47$YMlZ\'_A^[$G7\'YMl^8S*Il`kb~Z#vR$YS-Z>_b\'iY1~YCk^zi$z!U&7$YMlZ\'_A^[$G7\'YMl^8S*Z\'d_b~Z#vR#YS-Z>_b\'iX)~YCk^zi$z]G8S\'YT?`_iWAz!S2\'^CYT<b_iWAYSE^FYS,YTKiWAiXGz!WAYT>!UC-^z!TK8JD^z!T<8SH?Da?ca_91b^~^YS+D__|!S\'\'a)^~^YS+D__|!T>(i&i&y!VC8U+^z!W08T(ly!W>8T(ky!U((i&iX.y!=\'_CWiXFCW^CWiY5CWiX5CWiXM{!UI\'i$z!WL\'i$zCAX#YU0\'iT+!U6^z!U6i$])8U6G8T+CYSCCZ;aCWiX,CW`y{!79)i&iX;y!T+8T+CYSCCZ;YTN^\'i$~ZL^ZICZKvCvR3y!TN7#YU-^z!U-9@i&:KiWCai&kkz!WC:kw\'iV;]<\'_(Z<a@_D^~E^{]0\'^90Z?lb@`^\'`~B_D_~E_|]O9N`^Z0ka_@aD`4ZOd@b?ai$D`^~E_|!S1#`kiW=8E^~i$#`kiW=8E^~i$#`kiW=8E^~i$#`kiW=8E^~Z.YE^~Bw,YD^~BiV;YH^~Z.^z!S)#YS1a_iWI{]N#a_iV;#k_iV;~BiWC_{],4b4:Z,f@dbw,iV;~E@aD`^|]C4Z,:h-w*iV;4Z,f~BiWCfd?aaa^}(!S;(i&^z!S6(YS;`^{!SF(YS6b`^|]=(YSFca_wWE|!4#b`iW=9Cf?i&?bwW6awW6`9O?ea_`~YI_@`4ci$4cZ=?MdwW#?@HcwWGDHa4c?@HbwWG~BDHbwV$~E@a_~BwW#^4ci$4cA^4cAYSFZ=?MgwVIwW6wW6YS;YS6`wW6wW3~EMbHa~E@a_~BwVI^4ci%4cA^4cAZ=i$?MdwWK^~EMbHa~E@a_~BwWK^9CfMdH`D_`DH`~BwW3^9,c@a_~BwWG^#ZNew0#d~Z2bZ@i&:Z,iWCMeZ<??fi$i$akYJ_iW=H`~BwV\'^4:KgZMecKfYPdbiW.Ha_~BwWE^4YS)dZ0lbHbYPa_~ABwVJ_9Cf?i&?bwW6awW6`9O?ea_`~YI_@`4ci$4cZ=?MdwW#?@HcwWGDHa4c?@HbwWG~BDHbwV$~E@a_~BwW#^4ci$4cA^4cAYSFZ=?MgwVIwW6wW6YS;YS6`wW6wW3~EMbHa~E@a_~BwVI^4ci%4cA^4cAZ=i$?MdwWK^~EMbHa~E@a_~BwWK^9CfMdH`D_`DH`~BwW3^9,c@a_~BwWG^#ZNew0#d~Z2bZ@i&:Z,iWCMeZ<??fi$i$akYJ_iW=H`~BwV\'^4:KgZMecKfYPdbiW.Ha_~BwWE^4YS)dZ0lbHbYPa_~A^~^BwWF^#cHaiW=~BwW\'^D_~E_#bZ0k``iV=~YI_|!W.o!W=n!V=m!WIl!V;k]K8G_CYG^{!SC8Guy!W/878G^~Z$^z]/\'i$9/a@_CYG^9/a@_CYG^CYGvS#~ABvS#_9/a@_CYG^9/a@_CYG^CYGvS#~A^~^BvE^9/a@_CYGvS;CYGvS#~Bt^9/a@_CYGvS9CYGvS#~Bv0^9/a@_CYGvS5CYGvS#~Bu^9/a@_CYG^~J`D^~E^{!TD\'i$\'i$8TD@^CZ;D^~E^CYGvC~E^z!@8@YS,^9KvS7vF~YS$^9;YS0^CYGvF~Z5^9/i$YK^~Z(^8@YT?^~YI^8GvLCYTD@^CZ;D^CYGvK~E^9KvLvK~Z2^9KvS;vF~Bi%^9KvS-vF~J^z];8@^8GvECZ/i%YK^CYGvE~Z(^z!TA8TA8S(~Bu^\'^~YAk^Oy!S(8S(CO\'^8TA~BvR0^~YA_vC\'iX6~ZL^ZAy]J9J?`^9J?a^9J?at~BvS;^9J?av0~BvS9^9J?au~BvS5^O~BvS#^9*_~BvE^\'i&~ZL^Oz!S.(YS.^CO\'i&~AAYAvD`(YS.^CO\'i&~AA^~^BvL_(YS.^CO\'i&~A^~^BvK^ZAy!T\'(YT\'^ZI\'i&CO~BvL^YS(y!N\'_8NLLvRL_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~YAvS.^~YA_vS\'8NLLvR,_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~YAvS.^~YA_vS\'8NLLvR,_YF`v3CO~YAvR<^~YA_vR58NLLvR%_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~YAvS.^~YA_vS\'8NLLvR,_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~i$\'_8NLLvRL_YF`v3CO~YAvS.^~YA_vS\'8NLLvR,_YF`v3CO~YAvR<^~YA_vR58NLLvR%_YF`v3CO~YAvR/^~YA_vR$ZAz]I8SE`\'^~^^YTJ^YO?YS.^CO8OZJi&CO~BvE^(?i&ZIwW\'CO~BvJ^8SGZI5YNkk8NkCO~BvP^ZACO~ABvRM_8SGZI5YNkk8NkCO~BvP^ZACO~A^~^BvS?^\'i%CO~BvS;^\'i$CO~BvS-^ZACO~BvF^8T\'CO~BvK^\'^~YAk^YS(y]A\'^!V(^Oy!T:\'^!V(iY*\'^~BiX6^!V(^z!88T:^8T:YU1~BiY*^\'^~BiX6^iV(y!V(iY*]L+iX6^z!U0877%G\'_CYS4YEc^CYLYHc^YDYDGi$zYDYDGi$~YS$^z!S:87\'i$8S:@`^CX$D_~E_~YS$^{!<87\'i&(S@a_X$D_~E_~YS$^{!V8iD!SOiH]@#l`^{!S$YS#l!VP878LZPaYD_^~Z5^{!UJ8SGZPk^z!V&878T,b`YH^~Z5^|!V6878T9`YH^~Z5^{!W9878D^~Z5^z!S0878H^~Z5^z!SG#oYJ_^z]5YS#o!V.878LZPaYD_^~i$878LZPaYD_^~Z$_~Z(^{!WN8OZ&i&YK^z!/8OZ&YK`YK^{!T68Oa8T6?fZ>bb`a_Ll`~YCa_}\'!S*8T6i&b`^|!S5\'k\'iX6~E_\'l8S5@b@`\'l~YA`^\'iX6~YA__D`D^~E_~E^{!S8878S5YK`YK^~i$878S5YK`YK^~Z(_~Z(^{!VM3YU7`^{!W,3YU*`^{!U*8AYS8a_k{!U78AkYS8`^{!TE+kYS8`^{!UM8OZPvC^z!WD878T,b`YH^~Z(^|]>878T9`YH^~Z(^{]\'878D^~Z(^z!K878H^~Z(^z!T%\'i%\'i$8T%@_~Z$^D^~E^z!O87#nYJ_^~YT%^z](YS#n!TCi\'!S-i\'!W%j+!VKiU.!X$iUE!ULiC!U9i+!T-\'_\'i$\'i$8T-LLvR%`YFbu@_~YAvR/^~YA_vR$D^~E^{!T=8T-k^\'i$~Z2^z!TJ87\'i$5_k~^YT=^8T=@^~BvPD^\'i$~Z2^YK^~Z(^z!S7\'^8S7_`~YAak?b^Z?LYFu``vR%Z9u^{!S,8OYS7i&^8O?YS7i&L`kvP~YCk^z!TP\'^8F__~YU/`YTPZ9m`YTH_^\'l~Bk_{!WHi\'!V@i\'!W&i\'!V3i\'!X\'\'lz!V)i\'!W?8F_YSKYU:``_YS/`YS/^\'k~Bk_{!S<8S<_YU<__\'_~Bk^{!U:8S<`^8S<__~YA__YS/`YS/^{!UH9?b^\'^~BYAkbYAk`\'k~Bk^LYF`a_Z9`^{!U<5YFZ9b``^{!S/\'^5_k~YCk^z!WO\'_\'^~YC`^{!V5\'^\'_~YC`^{!U/3YU8^z!U8+YFZ9m`m^z!WM8Ck^z!W*8C_kz!W4+k^z]+3YC`^{!U.3YC__{!UE8C__{!C878A`^~i$878A`^~Z$_~Z$^{]#87+`^~i$87+`^~Z$_~Z$^{]9878SK`^9)_iX@~Bk_~i$878SK`^9)_iX@~Bk_~Z$_~Z$^{!TH878F`^~i$878F`^~Z$_~Z$^{!M875`^~i$875`^~Z$_~Z$^{!2879?`^~i$879?`^~Z$_~Z$^{]$3Z.^zCZ7ki#!V%YDi#!T1\'^!V%?iV%^YU>^8T1YDa_\'^~R`YD^YH_~E_{!SE878T1iV%^~Z(^z!W$iL!WBiH!T?878D^~YI^z!U>#m_i$z!IYS#m!T#\'`8T#?ca`Ll^~YC_k|]P8T#i&`^{!S+\'i$8S+@a_\'^~RD__D_~E_{]4iUF!UF\'i$8UF@a_\'^~BD__D_~E_{!SP\'i$8SP@`^\'_~RD`^~E_{!UPj%]%\'i$9%@`^\'_~BD`^~E_{!S>\'^8S>Ll`@^~YC`k{!T,8SHaYS>`^|!T9-YS>`^{!TI\'_8TI?aD_@^~E^{]*8TIi&^z]&\'_(Z&a@_D^~E^{!J\'k9?YJ@_l~E^z!TB92^92^8TB@a@^~E^\'i$~YTMa^@^~E^{!V-8TB_^z]2+i&^z!W@8S3@^z!V48S3D^z!VO8T5@^z!V98T5D^z!VF8T0@^z!VA8T0D^z!V/8T*@^z!UK8T*D^z!UN8PD^z!V,8SN@^z!UG8SND^z!X%8T/@^z!W)8T/D^z!W18T7@^z!VN8T7D^z!S36@^z!T56D^z!T08TF@^z!T*8TFD^z!SN1D^z!T/8T3@^z!T78T3D^z!TF)D^z!T3-D^z]M8P@^z!P1@^z!6)@^z!1-@^z]18797`^~E^{!SH878L`^~E^{!)878D^~E^z!-878H^~E^z!(#k`^{!.YS#k!;\'i$\'i$\'i$\'i$8;YHaYH_~RYDaYD_~RYEaYE_~Z.`\'i$~BpYE_~Z._\'^~^B`^{!TMi+!UO3_\'^~^Bi%^z!3+i$^z!S#0\'i$+bYE^~Z.^zz!SKj9!FiTH!5iM]?i2!AiC!X8:nn:k:k:ki&vS4vS=vS9!Y%:nl:ki&vP!X(:nki&!X+:np:k:k:k:k:ki&vR#vS4vS=vS9vR$!X>:np:k:k:k:k:ki&vR$vS;vS:vS6vS/!X9:nki&!X=:nv::k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS4vS(vS9vS.vS6vS9vS7vCvS,vS/vS;vCvS-vS6vCvS,vS+vS6vS*vCvRBvRKvRG!X2:nv>:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vDvRDvRAvRAvR:vR=vCvS:vS;vS5vS0vS9vS7vCvS;vS(vS/vS;vCvS,vS+vS6vS*vCvRBvRKvRG!Y7:nl:ki&vO!Y+:nl:ki&vO!X4:nl:ki&vC!Y,:nl:ki&vC!XA:nvR$:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS@vR+vS=vS2vS3vR/vJvDvS4vS2vS3vR/vKvDvR2vRGvS=vR3vR4vR/vRGvS=vR3vR4vR6vRGvS=vR3vR4vR6vRGvS=vR3vR4vR9vRGvS=vR3vR4vR9vS=vR3vR4vS<vJvR0vL!XN:nn:k:k:ki&vS4vS=vS9!Y-:nr:k:k:k:k:k:k:ki&vS@vS-vS0vS5vS0vS4vR$!X/:np:k:k:k:k:ki&vR$vS;vS:vS6vS/!Y(:nn:k:k:ki&vS4vS=vS9!Y6:nr:k:k:k:k:k:k:ki&uvS:vS,vS;vS@vS)vC!X-:nv8:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vCvR/vS/vS;vS.vS5vS,vS3vCvS,vS+vS6vS*vCvRBvRKvRGvCvMvMvM!XP:nki&!XJ:nn:k:k:ki&vS4vS=vS9!XB:nl:ki&vP!Y):nn:k:k:ki&vS)vS0vS3!XK:no:k:k:k:ki&vS4vS*vS:vR#!Y#:nki&!Y2:nl:ki&vR0!Y0:nl:ki&vO!Y&:nki&!X*:nki&!XL:nki&!XD:k:k:k:ki&w&w%w$w#!X0:nv/:k:k:k:k:k:k:k:k:k:k:k:ki&vS+vS,vS;vS*vS,vS7vS?vS,vCvS)vS0vS9!Y\':nu:k:k:k:k:k:k:k:k:k:ki&vS7vS6vCvS5vS>vS6vS5vS2vS5vS<!X::nv5:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS:vS5vS6vS*vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!Y.:nv3:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS,vS.vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!X3:nv3:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS,vS:vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!Y3:nv4:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS3vS3vS(vS*vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!XO:nv4:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS7vS4vS<vS1vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!X<:nl:ki&vS&!Y4:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&:k:ki&v7wT(:k:ki&v6wG:k:ki&v5wU1:k:ki&v4x9:k:ki&v3wTH:k:ki&v2wM:k:ki&v1w2:k:ki&v0wC:k:ki&v/w+:k:ki&v.wS4:k:ki&ux7:k:ki&twL:k:ki&swE:k:ki&rwD:k:ki&qwH:k:ki&px.:k:ki&ow0:k:ki&nw*:k:ki&mw,:k:ki&lw\':k:ki&kw#!XE:nv7:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS5vS(vS;vS:vS5vS6vS*vCvS+vS3vS0vS<vS)vCvS;vJvS5vS(vS*!XH:k:k:ki&i&i%i$!X1:ki&k!XC:nv0:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvR/vS:vS;vS9vS6vS7vS?vS,vCvMvMvM!XI:nv1:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvR/vS,vS+vS6vS*vCvRBvRKvRGvCvMvMvM!X7:ki&wW6!Y$:nki&!Y/:nki&!X?:nl:ki&vR$!Y1:nm:k:ki&vR$vR#!X):nki&!XG:nn:k:k:ki&vR5vR5vR5!X.:nki&!XF:nv.:k:k:k:k:k:k:k:k:k:k:ki&uvR#vS@vS3vS3vS(vS<vS5vS(vS4vC!Y5:nvE:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vCvS.vS5vS0vS5vS5vS<vS9vCvS@vS9vS;vCvS6vS;vCvS;vS5vS(vS>vCvS;vS/vS.vS0vS4vCvS<vS6vRNvCvMvMvM!X5:nvO:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvR#vS+vS,vS0vS-vS0vS5vS0vS4vCvS;vS6vS5vCvS:vS(vS>vCvS,vS+vS6vS*vCvS+vS,vS;vS(vS9vS,vS5vS,vS.vCvS,vS/vS;vCvS6vS:vCvMvMvM!XM:nvR/:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvS4vS,vS;vS:vS@vS:vCvS,vS4vS,vS/vS*vRHvCvS:vS0vS/vS;vCvS/vS;vS0vS>vCvS+vS,vS;vS9vS6vS7vS7vS<vS:vCvS;vS6vS5vCvS:vS0vCvS5vS6vS0vS;vS(vS*vS0vS-vS0vS5vS0vRBvCvMvMvM!X,:nl:ki&vC!X;:nv1:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS9vS6vS9vS9vS,vCvS,vS7vS@vS;vCvMvMvM!Y*YMmk!X6YMlk!X@:nv2:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vR%vCvS@vS)vCvS,vS+vS0vS=vS0vS+vCvMvMvM!\':lkl!,:lkm!*:lkn!0:lko].:lkp!H:lkq!D:lkr!E:lks!L:lkt]7:lku!S4:lkv.!+:lkv/!C:lkv0!2:lkv1!M:lkv2!TH:lkv3]9:lkv4!U1:lkv5!G:lkv6!T(:lkv7y"

let debug = Sys.getenv_opt "RIBBIT_DEBUG" |> Option.is_some
let tracing = ref false
let step_count = ref 0
let start_tracing = ref 0
let next_stamp = ref 0

let _ = if debug then Printexc.record_backtrace true

module Rib = struct
  (* Rib (car, cdr, tag) *)
  type t = Rib of t ref * t ref * t ref | Integer of int

  let make_rib_of_ints a b c =
    Rib (ref (Integer a), ref (Integer b), ref (Integer c))
  let make_rib a b c = Rib (ref a, ref b, ref c)

  let is_rib = function Rib _ -> true | _ -> false
  let is_int = function Integer _ -> true | _ -> false

  let int_val = function Integer i -> i
                     | _ -> invalid_arg "int_val expects an Integer"
  let int_val_orelse i def =
    match i with
    |  Integer i -> i
    | _ -> def

  let rib_eq a b =
    match a, b with
    | Integer x, Integer y -> x = y
    | Rib _, Rib _ -> a == b
    | _ -> false

  let get_car = function Rib (car,_,_) -> !car
                       | _ -> invalid_arg "get_car expects a rib"
  let set_car rib newval =
    match rib with
    | Rib (car,_,_) -> car := newval
    | _ -> invalid_arg "set_car expects a rib"
  let get_cdr = function Rib (_,cdr,_) -> !cdr
                       | _ -> invalid_arg "get_cdr expects a rib"
  let set_cdr rib newval =
    match rib with
    | Rib (_,cdr,_) -> cdr := newval
    | _ -> invalid_arg "set_cdr expects a rib"
  let get_tag = function Rib (_,_,tag) -> !tag
                       | _ -> invalid_arg "get_tag expects a rib"
  let set_tag rib newval =
    match rib with
    | Rib (_,_,tag) -> tag := newval
    | _ -> invalid_arg "set_tag expects a rib"

  let false_rib = make_rib_of_ints 0 0 5
  let true_rib = make_rib_of_ints 0 0 5
  let nil_rib = make_rib_of_ints 0 0 5

  let to_bool = function true -> true_rib | false -> false_rib

  let write_to_buffer rib buf =
    let rec helper r =
      match r with
      | Integer i -> Printf.bprintf buf "%d" i
      | Rib _ when r == true_rib -> Buffer.add_string buf "#t"
      | Rib _ when r == false_rib -> Buffer.add_string buf "#f"
      | Rib _ when r == nil_rib -> Buffer.add_string buf "()"
      | Rib (car, cdr, tag) ->
         let obj = ref r in
         let typ = int_val_orelse !tag (-1) in
         if typ = 4 then begin
             Buffer.add_char buf '#';
             helper !car
           end else if typ = 0 then begin
             let n = ref 0 in
             Buffer.add_char buf '(';
             helper !car;
             let obj = ref !cdr in
             while is_rib !obj && int_val_orelse (get_tag !obj) (-1) = 0 do
               if !n > 4 then begin
                   Buffer.add_string buf " ...";
                   obj := nil_rib
                 end else begin
                   Buffer.add_char buf ' ';
                   helper (get_car !obj);
                   obj := get_cdr !obj;
                   incr n
                 end
             done;
             if not (!obj == nil_rib) then begin
                 Buffer.add_string buf " . ";
                 helper !obj
               end;
             Buffer.add_char buf ')'
           end else if typ = 1 then begin
             if is_rib !car then
               Printf.bprintf buf "#<procedure params=%d>" (int_val (get_car !car))
             else
               Printf.bprintf buf "#<primitive %d>" (int_val !car)
           end else if typ = 2 then begin
             obj := get_cdr !obj;
             if is_rib !obj && int_val (get_tag !obj) = 3 &&
                  int_val (get_cdr !obj) > 0 then begin
                 obj := get_car !obj;
                 while is_rib !obj && int_val (get_tag !obj) = 0 do
                   Buffer.add_char buf (get_car !obj |> int_val |> char_of_int);
                   obj := get_cdr !obj
                 done;
               end else begin
                 Buffer.add_string buf "#<symbol ";
                 helper !obj;
                 Buffer.add_char buf '>'
               end
           end else if typ = 3 then begin
             Buffer.add_char buf '"';
             obj := !car;
             while is_rib !obj && int_val (get_tag !obj) = 0 do
               begin
                 match (get_car !obj |> int_val |> char_of_int) with
                 | '\n' -> Buffer.add_string buf "\\n"
                 | '\r' -> Buffer.add_string buf "\\r"
                 | '\t' -> Buffer.add_string buf "\\t"
                 | '\\' -> Buffer.add_string buf "\\\\"
                 | '"' -> Buffer.add_string buf "\\\""
                 | c -> Buffer.add_char buf c
               end;
               obj := get_cdr !obj
             done;
             Buffer.add_char buf '"'
           end else begin
             Buffer.add_char buf '[';
             helper !car;
             Buffer.add_char buf ',';
             helper !cdr;
             Buffer.add_char  buf ',';
             helper !tag;
             Buffer.add_char buf ']'
           end in
    helper rib;
    buf

  let print_rib ?(out=stdout) rib =
    Buffer.create 16 |> write_to_buffer rib |> Buffer.output_buffer out
end

open Rib

let stack = ref (Integer 0)

let start_step () =
  incr step_count;
  if !step_count >= !start_tracing then tracing := true;
  if not !tracing then begin
      if !step_count >= !next_stamp then begin
          next_stamp := (float_of_int !next_stamp) *. 1.01 +. 1.0 |>  int_of_float;
          Printf.printf "@%d\n" !step_count;
        end
    end else begin
      let s = ref !stack in
      let buf = Buffer.create 80 in
      let sep = ref "" in
      Printf.bprintf buf "@%d STACK = (" !step_count;
      while is_rib !s && int_val_orelse (get_tag !s) (-1) = 0 do
        Buffer.add_string buf !sep;
        write_to_buffer (get_car !s) buf |> ignore;
        sep := " ";
        s := get_cdr !s
      done;
      Buffer.add_char buf ')';
      Buffer.output_buffer stdout buf;
      print_newline ();
      flush stdout
    end

let push x = stack := make_rib x !stack (Integer 0)
let pop () =
  match !stack with
  | Rib (car,cdr,_) ->
     stack := !cdr;
     !car
  | _ -> invalid_arg "Top of stack is not a rib"

module type PRIMITIVES = sig
  val primitives: (unit -> unit) array
end

module Primitives : PRIMITIVES = struct
  let prim0 f = function () -> f () |> push
  let prim1 f = function () -> pop () |> f |> push
  let prim2 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  f x y |> push
  let prim3 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  let z = pop () in
                  f x y z |> push

  let getchar () =
    try
      input_char stdin |> int_of_char
    with End_of_file -> -1

  let putchar c =
    char_of_int c |> print_char;
    flush stdout;
    c

  let primitives = [|
      prim3 (fun z y x -> make_rib x y z);
      prim1 (function x -> x);
      (function () -> pop () |> ignore);
      prim2 (fun y x -> y);
      prim1 (function x -> make_rib (get_car x) !stack (Integer 1));
      prim1 (function Rib _ -> true_rib | _ -> false_rib);
      prim1 get_car;
      prim1 get_cdr;
      prim1 get_tag;
      prim2 (fun y x -> set_car x y; y);
      prim2 (fun y x -> set_cdr x y; y);
      prim2 (fun y x -> set_tag x y; y);
      prim2 (fun y x -> to_bool (rib_eq x y));
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> to_bool (a < b)
                        | _ -> invalid_arg "< arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a + b)
                        | _ -> invalid_arg "+ arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a - b)
                        | _ -> invalid_arg "- arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a * b)
                        | _ -> invalid_arg "* arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a / b)
                        | _ -> invalid_arg "quotient arguments must be Integers");
      prim0 (function () -> Integer (getchar ()));
      prim1 (function Integer ch -> Integer (putchar ch) | _ -> invalid_arg "putchar argument must be Integer");
      prim1 (function Integer status -> exit status | _ -> invalid_arg "exit argument must be Integer")
    |]
end

let get_byte =
  let input_stream = Stream.of_string input in
  function () -> (Stream.next input_stream |> int_of_char)

let get_code () =
  let x = (get_byte ()) - 35 in if x < 0 then 57 else x

let rec get_int n =
  let x = get_code () in
  let n = n * 46 in
  if x < 46 then n + x else get_int (n + x - 46)

let rec list_tail lst i =
  if i = 0 then lst else list_tail (get_cdr lst) (i - 1)

(* Build the initial symbol table *)
let symtbl = ref nil_rib
let _ =
  for n = get_int 0 downto 1 do
    symtbl := make_rib (make_rib false_rib
                          (make_rib nil_rib (Integer 0) (Integer 3))
                          (Integer 2))
                !symtbl (Integer 0)
  done;
  let accum = ref nil_rib
  and n = ref 0
  and in_loop = ref true in
  while !in_loop do
    let c = get_byte () in
    if c = 44 then begin
        let r1 = make_rib !accum (Integer !n) (Integer 3) in
        let r2 = make_rib false_rib r1 (Integer 2) in
        symtbl := make_rib r2 !symtbl (Integer 0);
        accum := nil_rib;
        n := 0
      end
    else if c = 59 then
      in_loop := false
    else begin
        accum := make_rib (Integer c) !accum (Integer 0);
        incr n
      end
  done;
  symtbl := make_rib (make_rib false_rib
                        (make_rib !accum (Integer !n) (Integer 3))
                        (Integer 2))
              !symtbl (Integer 0)

let symbol_ref n = list_tail !symtbl n |> get_car

let pc = ref nil_rib

(* Decode the RVM instructions *)
let _ =
  let codes = [| 20; 30; 0; 10; 11; 4 |]
  and in_loop = ref true
  and n = ref nil_rib in
  while !in_loop do
    let x = get_code ()
    and d = ref 0
    and op = ref 0
    and in_loop2 = ref true in
    n := Integer x;
    while !in_loop2 do
      d := codes.(!op);
      if int_val !n <= 2 + !d then
        in_loop2 := false
      else begin
          n := Integer ((int_val !n) - (!d + 3));
          incr op
        end
    done;
    if x > 90 then
      n := pop ()
    else begin
        if !op = 0 then begin
            stack := make_rib (Integer 0) !stack (Integer 0);
            incr op
          end;
        n := if int_val !n = !d then
               Integer (get_int 0)
             else if int_val !n >= !d then
               get_int ((int_val !n) - !d - 1) |> symbol_ref
             else if !op < 3 then
               int_val !n |> symbol_ref
             else
               !n;
        if 4 < !op then begin
            n := make_rib (make_rib !n (Integer 0) (pop ())) nil_rib (Integer 1);
            if not (is_rib !stack) then
              in_loop := false
            else
              op := 4
          end;
      end;
    if !in_loop then
      set_car !stack (make_rib (Integer (!op - 1)) !n (get_car !stack))
  done;
  pc := get_car !n |> get_tag

let get_opnd o =
  match o with
  | Rib _ -> o
  | Integer i -> list_tail !stack i

let get_cont () =
  let s = ref !stack in
  while not (is_rib (get_tag !s)) do
    s := get_cdr !s
  done;
  !s

let set_global v =
  set_car (get_car !symtbl) v;
  symtbl := (get_cdr !symtbl)

(* Execute the program *)
let _ =
  set_global (make_rib (Integer 0) !symtbl (Integer 1));
  set_global false_rib;
  set_global true_rib;
  set_global nil_rib;
  stack := make_rib (Integer 0) (Integer 0) (make_rib_of_ints 5 0 0);
  while true do
    if debug then start_step ();
    let o = ref (get_cdr !pc)
    and i = int_val (get_car !pc) in
    if i < 1 then begin (* jump/call *)
        if !tracing then begin
            (if is_rib (get_tag !pc) then "call " else "jump ") |> prerr_string;
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        o := get_opnd !o |> get_car;
        let c = ref (get_car !o) in
        if is_rib !c then begin
            let c2 = ref (make_rib (Integer 0) !o (Integer 0)) in
            let s2 = ref !c2
            and nargs = int_val (get_car !c) in
            for narg = nargs downto 1 do
              s2 := make_rib (pop ()) !s2 (Integer 0)
            done;
            if is_rib (get_tag !pc) then begin (* call *)
                set_car !c2 !stack;
                set_tag !c2 (get_tag !pc)
              end else begin (* jump *)
                let k = get_cont () in
                set_car !c2 (get_car k);
                set_tag !c2 (get_tag k)
              end;
            stack := !s2
          end else begin
            Primitives.primitives.(int_val !c) ();
            if is_rib (get_tag !pc) then (* call *)
              c := !pc
            else begin (* jump *)
                c := get_cont ();
                set_cdr !stack (get_car !c)
              end
          end;
        pc := get_tag !c
      end else if i < 2 then begin (* set *)
        if !tracing then begin
            prerr_string "set ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        set_car opnd (get_car !stack);
        stack := get_cdr !stack;
        pc := get_tag !pc
      end else if i < 3 then begin (* get *)
        if !tracing then begin
            prerr_string "get ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        push (get_car opnd);
        pc := get_tag !pc
      end else if i < 4 then begin (* const *)
        if !tracing then begin
            prerr_string "const ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        push !o;
        pc := get_tag !pc
      end else if i < 5 then begin (* if *)
        if !tracing then prerr_endline "if";
        pc := if pop () == false_rib then get_tag !pc else get_cdr !pc
      end else begin (* halt *)
        if !tracing then prerr_endline "halt";
        exit 0
      end
  done
