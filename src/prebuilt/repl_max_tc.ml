(* RVM code that prints HELLO! *)
let input = "R.dnoc,radadc,?=<rahc,rdaddc,?=>gnirts,etacnurt,raaddc,raddac,?orez,dneppa-gnirts,?evitagen,nigeb,rotaremun,qssa,nim,mcl,=>,gnirtsbus,regetni>-rahc,qmem,etouq,radddc,?>rahc,?=>rahc,xam,>,rddadc,?naeloob,ypoc-gnirts,=,gnirts-ekam,=<,fer-rotcev,radaac,raaadc,rotanimoned,?<rahc,rddaac,raaaac,!rdc-tes,rahc>-regetni,rdaaac,rotcev-ekam,roolf,gniliec,fi,oludom,dna,?evitisop,rahc-etirw,htgnel-rotcev,?=gnirts,!tes-gnirts,!tes-rotcev,?qe,rdaadc,rddddc,?=rahc,htgnel-gnirts,enifed,ro,adbmal,+,tel,rdadac,?=<gnirts,dnuor,raadac,!tes,!llif-gnirts,!llif-rotcev,dcg,rebmem,cc/llac,redniamer,fer-gnirts,vmem,?<gnirts,hcae-rof,*,lave,vssa,gnirts>-rebmun,!rac-tes,?ddo,pam,?>gnirts,gnirts>-lobmys,tsil>-rotcev,rebmun>-gnirts,tpxe,lobmys>-gnirts,cossa,esrever,?neve,raadc,raaac,rdddac,rdaac,-,raac,radac,rdadc,radc,fer-tsil,enilwen,rdddc,raddc,rorre,dneppa,rotcev>-tsil,?tcejbo-foe,lper,sba,?erudecorp,tneitouq,?llun,htgnel,etirw,yalpsid,?lobmys,daer,?rotcev,?lauqe,rahc-keep,rddac,gnirts>-tsil,ton,,tsil>-gnirts,,?gnirts,<,,?regetni,rddc,,,,,,rdac,,,rahc-daer,,?riap,,snoc,rac,rdc,,?vqe,,,,,;8P@MX#ZI\'iP!U2^z!U2i$]&8U2YTA8P@Z)@YJa@YIiUA@YI`y{!/9&i&iU:y!P8P@Z)@YJZB^\'i$~Z#^YG@YT@vCvR3y]B7#YU6^z!U68TMi&:HiU8ai&kkz!U8:kw\'k!TE\'_,YTEaA_B^~E^{!T=\'^8T=YT8lbA`^\'`~?_B_~E_|!TG8TO`^YT=ka_AaB`1YTGdAbCai$B`^~E_|!U4#`kn8>^~i$#`kn8>^~i$#`kn8>^~i$#`kn8>^~YT9U^~?w)O^~?kR^~YT9^z!U/#YU4a_l{!TO#a_k#k_k~?iU8_{!T71b1:YT7fAdbw)k~EAaB`^|!TB1YT7:h-w6k1YT7f~?iU8fdCaaa^}(!TJ,i&^z!TL,YTJ`^{!TP,YTLb`^|!T:,YTPca_wS7|!1#b`n8TBfCi&CbwU<awU<`8TGCea_`~YH_A`1ci$1cYT:CPdwT6CAJcwT+BJa1cCAJbwT+~?BJbwU@~EAa_~?wT6^1ci$1cM^1cMYTPYT:CPgwS(wU<wU<YTJYTL`wU<wS%~EPbJa~EAa_~?wS(^1ci%1cM^1cMYT:i$CPdwS5^~EPbJa~EAa_~?wS5^8TBfPdJ`B_`BJ`~?wS%^8T7cAa_~?wT+^#YTOewTA#d~YLbYTMi&:YT7iU8PeYTECCfi$i$akYK_nJ`~?wS\'^1:HgZ1ecHfYCdboJa_~?wS7^1YU/dYT=lbJbYCa_~M?wS)_8TBfCi&CbwU<awU<`8TGCea_`~YH_A`1ci$1cYT:CPdwT6CAJcwT+BJa1cCAJbwT+~?BJbwU@~EAa_~?wT6^1ci$1cM^1cMYTPYT:CPgwS(wU<wU<YTJYTL`wU<wS%~EPbJa~EAa_~?wS(^1ci%1cM^1cMYT:i$CPdwS5^~EPbJa~EAa_~?wS5^8TBfPdJ`B_`BJ`~?wS%^8T7cAa_~?wT+^#YTOewTA#d~YLbYTMi&:YT7iU8PeYTECCfi$i$akYK_nJ`~?wS\'^1:HgZ1ecHfYCdboJa_~?wS7^1YU/dYT=lbJbYCa_~M^~^?xN^#cJan~?wSP^B_~E_#bYT=k``m~YH_|!T@5_@L^{])5uy!S3/5^~Q^z!@\'i$8@aA_@L^8@aA_@L^@LvS#~M?vS#_8@aA_@L^8@aA_@L^@LvS#~M^~^?vE^8@aA_@LvS;@LvS#~?t^8@aA_@LvS9@LvS#~?v0^8@aA_@LvS5@LvS#~?u^8@aA_@L^~YA`B^~E^{!U\'\'i$\'i$8U\'A^@YJB^~E^@LvC~E^z!I8IZ@^8T@vS7vF~YN^8JZ:^@LvF~YF^8@i$V^~T^8IZ;^~YH^5vL@YU\'A^@YJB^@LvK~E^8T@vLvK~YL^8T@vS;vF~?i%^8T@vS-vF~YA^z!J8I^5vE@Wi%V^@LvE~T^z!U(8U(8TC~?u^\'^~Ik^Gy!TC8TC@G\'^8U(~?vR0^~I_vC\'iU>~Z#^YDy!T;8T;C`^8T;Ca^8T;Cat~?vS;^8T;Cav0~?vS9^8T;Cau~?vS5^G~?vS#^95_~?vE^\'i&~Z#^Gz!TD,YTD^@G\'i&~MMIvD`,YTD^@G\'i&~MM^~^?vL_,YTD^@G\'i&~M^~^?vK^YDy!U%,YU%^YG\'i&@G~?vL^YTCy!7\'_87DDvRL_K`v3@G~i$\'_87DDvRL_K`v3@G~IvS.^~I_vS\'87DDvR,_K`v3@G~i$\'_87DDvRL_K`v3@G~i$\'_87DDvRL_K`v3@G~IvS.^~I_vS\'87DDvR,_K`v3@G~IvR<^~I_vR587DDvR%_K`v3@G~i$\'_87DDvRL_K`v3@G~i$\'_87DDvRL_K`v3@G~IvS.^~I_vS\'87DDvR,_K`v3@G~i$\'_87DDvRL_K`v3@G~i$\'_87DDvRL_K`v3@G~IvS.^~I_vS\'87DDvR,_K`v3@G~IvR<^~I_vR587DDvR%_K`v3@G~IvR/^~I_vR$YDz!G97`\'^~^^Z9^YBCYTD^@G8BYT;i&@G~?vE^,Ci&YGwSP@G~?vJ^9$YG-Nkk87k@G~?vP^YD@G~M?vRM_9$YG-Nkk87k@G~?vP^YD@G~M^~^?vS?^\'i%@G~?vS;^\'i$@G~?vS-^YD@G~?vF^8U%@G~?vK^\'^~Ik^YTCy!D\'^!U?^Gy!U$\'^!U?iU9\'^~?iU>^!U?^z!08U$^8U$YU3~?iU9^\'^~?iU>^iU?y!U?iU9]#(iU>^z]I/7%YTA\'_@YU7Uc^@YT<Rc^OOYTAi$zOOYTAi$~YN^z]D/\'i$9DA`^@X$B_~E_~YN^{]=/\'i&,Z=Aa_X$B_~E_~YN^{!TM#l`^{!NYT>l]L/8T<YT?aO_^~YF^{!S:9$YT?k^z!S//8U,b`R^~YF^|!SD/9*`R^~YF^{!S2/88^~YF^z]:/8;^~YF^z]$#oYK_^z!FYT>o]M/8T<YT?aO_^~i$/8T<YT?aO_^~Q_~T^{!SH8BZ%i&V^z!T-8BZ%V`V^{!U08Ba8U0CfZGbb`a_Dl`~Sa_}\'!T%8U0i&b`^|!TH\'k\'iU>~E_\'l8THAbA`\'l~I`^\'iU>~I__B`B^~E_~E^{!TI/8THV`V^~i$/8THV`V^~T_~T^{!T28AZE`^{!S#8AZ<`^{]<2YTIa_k{]E2kYTI`^{!S1(kYTI`^{!SF8BYT?vC^z!S0/8U,b`R^~T^|]G/9*`R^~T^{!S*/88^~T^z!?/8;^~T^z!U&\'i%\'i$8U&A_~Q^B^~E^z!B/#nYK_^~YU&^z!=YT>n!S<i\'!T$i\'!SMiT&!T4iSE!SNiSK!S@i<!S+i(!U.\'_\'i$\'i$8U.DDvR%`KbuA_~IvR/^~I_vR$B^~E^{!U)8U.k^\'i$~YL^z]9/\'i$-_k~^YU)^8U)A^~?vPB^\'i$~YL^V^~T^z!U#\'^8U#_`~IakCb^YT8DKu``vR%YMu^{]@8BYU#i&^8BCYU#i&D`kvP~Sk^z]8\'^4__~Z>`Z8YMm`ZC_^\'l~?k_{]Pi\'!T1i\'!S8i\'!S9i\'!SA\'lz!T*i\'!T\'4_YTKZK``_YO`YO^\'k~?k_{!TF8TF_ZH__\'_~?k^{]K8TF`^8TF__~I__YO`YO^{!S68T8b^\'^~?IkbIk`\'k~?k^DK`a_YM`^{]H-KYMb``^{!O\'^-_k~Sk^z!T(\'_\'^~S`^{!SL\'^\'_~S`^{]>8AZ4^z]4(KYMm`m^z!T,8<k^z!S48<_kz!T.(k^z!T&8AS`^{!SE8AS__{!SK8<__{!</2`^~i$/2`^~Q_~Q^{!SG/(`^~i$/(`^~Q_~Q^{!M/8TK`^9&_iU;~?k_~i$/8TK`^9&_iU;~?k_~Q_~Q^{]C/4`^~i$/4`^~Q_~Q^{]//-`^~i$/-`^~Q_~Q^{!S&/8T8`^~i$/8T8`^~Q_~Q^{!:8AYT9^z@YU-ki#!U=Oi#!U*\'^!U=CiU=^YU5^8U*Oa_\'^~YE`O^R_~E_{]7/8U*iU=^~T^z];/88^~YH^z!U5#m_i$z!HYT>m!U+\'`8U+Cca`Dl^~S_k|!T?8U+i&`^{]6\'i$96Aa_\'^~YEB__B_~E_{!T)jA]A\'i$9AAa_\'^~?B__B_~E_{]J\'i$9JA`^\'_~YEB`^~E_{!T#jF]F\'i$9FA`^\'_~?B`^~E_{!TN\'^8TNDl`A^~S`k{!U,9?aYTN`^|]*+YTN`^{!U1\'_8U1CaB_A^~E^{]58U1i&^z]%\'_,Z%aA_B^~E^{!K\'k8T8YKA_l~E^z!L(i&^z!S,9(A^z!SO9(B^z!T39\'A^z!T09\'B^z!SJ9,A^z!T59,B^z!S-93A^z!SB93B^z!T/8CB^z!S$9-A^z]O9-B^z!S?90A^z!SC90B^z!S;92A^z!S>92B^z](89A^z]\'89B^z],9+A^z]39+B^z]-3B^z]09.A^z]29.B^z]+*B^z].+B^z]18CA^z!C3A^z!9*A^z!3+A^z!S=/8U-`^~E^{]?/8T<`^~E^{!*/88^~E^z!+/8;^~E^z!,#k`^{!.YT>k!E\'i$\'i$\'i$\'i$8ERaR_~YEOaO_~YEUaU_~YT9`\'i$~?pU_~YT9_\'^~^?`^{!S.i(!SI8A_\'^~^?i%^z!A(i$^z!T>8TA\'i$(bU^~YT9^zz!TKiM!4jC!-j/!T8iS&!2i<!UA:nl:ki&vC!U::nv1:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS9vS6vS9vS9vS,vCvS,vS7vS@vS;vCvMvMvM!U9Z/mk!U>Z/lk!U;:nv2:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vR%vCvS@vS)vCvS,vS+vS0vS=vS0vS+vCvMvMvM!\':lkl!):lkm!6:lkn!TA:lko!T9:lkp!;:lkq!8:lkr!>:lks!T<:lkt!U-:lku!U7:lkv.!(:lkv/!<:lkv0!S&:lkv1]/:lkv2]C:lkv3!M:lkv4!U3:lkv5!5:lkv6y"

let debug = Sys.getenv_opt "RIBBIT_DEBUG" |> Option.is_some
let tracing = ref false
let step_count = ref 0
let start_tracing = ref 0
let next_stamp = ref 0

let _ = if debug then Printexc.record_backtrace true

module Rib = struct
  (* Rib (car, cdr, tag) *)
  type t = Rib of t ref * t ref * t ref | Integer of int

  let make_rib_of_ints a b c =
    Rib (ref (Integer a), ref (Integer b), ref (Integer c))
  let make_rib a b c = Rib (ref a, ref b, ref c)

  let is_rib = function Rib _ -> true | _ -> false
  let is_int = function Integer _ -> true | _ -> false

  let int_val = function Integer i -> i
                     | _ -> invalid_arg "int_val expects an Integer"
  let int_val_orelse i def =
    match i with
    |  Integer i -> i
    | _ -> def

  let rib_eq a b =
    match a, b with
    | Integer x, Integer y -> x = y
    | Rib _, Rib _ -> a == b
    | _ -> false

  let get_car = function Rib (car,_,_) -> !car
                       | _ -> invalid_arg "get_car expects a rib"
  let set_car rib newval =
    match rib with
    | Rib (car,_,_) -> car := newval
    | _ -> invalid_arg "set_car expects a rib"
  let get_cdr = function Rib (_,cdr,_) -> !cdr
                       | _ -> invalid_arg "get_cdr expects a rib"
  let set_cdr rib newval =
    match rib with
    | Rib (_,cdr,_) -> cdr := newval
    | _ -> invalid_arg "set_cdr expects a rib"
  let get_tag = function Rib (_,_,tag) -> !tag
                       | _ -> invalid_arg "get_tag expects a rib"
  let set_tag rib newval =
    match rib with
    | Rib (_,_,tag) -> tag := newval
    | _ -> invalid_arg "set_tag expects a rib"

  let false_rib = make_rib_of_ints 0 0 5
  let true_rib = make_rib_of_ints 0 0 5
  let nil_rib = make_rib_of_ints 0 0 5

  let to_bool = function true -> true_rib | false -> false_rib

  let write_to_buffer rib buf =
    let rec helper r =
      match r with
      | Integer i -> Printf.bprintf buf "%d" i
      | Rib _ when r == true_rib -> Buffer.add_string buf "#t"
      | Rib _ when r == false_rib -> Buffer.add_string buf "#f"
      | Rib _ when r == nil_rib -> Buffer.add_string buf "()"
      | Rib (car, cdr, tag) ->
         let obj = ref r in
         let typ = int_val_orelse !tag (-1) in
         if typ = 4 then begin
             Buffer.add_char buf '#';
             helper !car
           end else if typ = 0 then begin
             let n = ref 0 in
             Buffer.add_char buf '(';
             helper !car;
             let obj = ref !cdr in
             while is_rib !obj && int_val_orelse (get_tag !obj) (-1) = 0 do
               if !n > 4 then begin
                   Buffer.add_string buf " ...";
                   obj := nil_rib
                 end else begin
                   Buffer.add_char buf ' ';
                   helper (get_car !obj);
                   obj := get_cdr !obj;
                   incr n
                 end
             done;
             if not (!obj == nil_rib) then begin
                 Buffer.add_string buf " . ";
                 helper !obj
               end;
             Buffer.add_char buf ')'
           end else if typ = 1 then begin
             if is_rib !car then
               Printf.bprintf buf "#<procedure params=%d>" (int_val (get_car !car))
             else
               Printf.bprintf buf "#<primitive %d>" (int_val !car)
           end else if typ = 2 then begin
             obj := get_cdr !obj;
             if is_rib !obj && int_val (get_tag !obj) = 3 &&
                  int_val (get_cdr !obj) > 0 then begin
                 obj := get_car !obj;
                 while is_rib !obj && int_val (get_tag !obj) = 0 do
                   Buffer.add_char buf (get_car !obj |> int_val |> char_of_int);
                   obj := get_cdr !obj
                 done;
               end else begin
                 Buffer.add_string buf "#<symbol ";
                 helper !obj;
                 Buffer.add_char buf '>'
               end
           end else if typ = 3 then begin
             Buffer.add_char buf '"';
             obj := !car;
             while is_rib !obj && int_val (get_tag !obj) = 0 do
               begin
                 match (get_car !obj |> int_val |> char_of_int) with
                 | '\n' -> Buffer.add_string buf "\\n"
                 | '\r' -> Buffer.add_string buf "\\r"
                 | '\t' -> Buffer.add_string buf "\\t"
                 | '\\' -> Buffer.add_string buf "\\\\"
                 | '"' -> Buffer.add_string buf "\\\""
                 | c -> Buffer.add_char buf c
               end;
               obj := get_cdr !obj
             done;
             Buffer.add_char buf '"'
           end else begin
             Buffer.add_char buf '[';
             helper !car;
             Buffer.add_char buf ',';
             helper !cdr;
             Buffer.add_char  buf ',';
             helper !tag;
             Buffer.add_char buf ']'
           end in
    helper rib;
    buf

  let print_rib ?(out=stdout) rib =
    Buffer.create 16 |> write_to_buffer rib |> Buffer.output_buffer out
end

open Rib

let stack = ref (Integer 0)

let start_step () =
  incr step_count;
  if !step_count >= !start_tracing then tracing := true;
  if not !tracing then begin
      if !step_count >= !next_stamp then begin
          next_stamp := (float_of_int !next_stamp) *. 1.01 +. 1.0 |>  int_of_float;
          Printf.printf "@%d\n" !step_count;
        end
    end else begin
      let s = ref !stack in
      let buf = Buffer.create 80 in
      let sep = ref "" in
      Printf.bprintf buf "@%d STACK = (" !step_count;
      while is_rib !s && int_val_orelse (get_tag !s) (-1) = 0 do
        Buffer.add_string buf !sep;
        write_to_buffer (get_car !s) buf |> ignore;
        sep := " ";
        s := get_cdr !s
      done;
      Buffer.add_char buf ')';
      Buffer.output_buffer stdout buf;
      print_newline ();
      flush stdout
    end

let push x = stack := make_rib x !stack (Integer 0)
let pop () =
  match !stack with
  | Rib (car,cdr,_) ->
     stack := !cdr;
     !car
  | _ -> invalid_arg "Top of stack is not a rib"

module type PRIMITIVES = sig
  val primitives: (unit -> unit) array
end

module Primitives : PRIMITIVES = struct
  let prim0 f = function () -> f () |> push
  let prim1 f = function () -> pop () |> f |> push
  let prim2 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  f x y |> push
  let prim3 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  let z = pop () in
                  f x y z |> push

  let getchar () =
    try
      input_char stdin |> int_of_char
    with End_of_file -> -1

  let putchar c =
    char_of_int c |> print_char;
    flush stdout;
    c

  let primitives = [|
      prim3 (fun z y x -> make_rib x y z);
      prim1 (function x -> x);
      (function () -> pop () |> ignore);
      prim2 (fun y x -> y);
      prim1 (function x -> make_rib (get_car x) !stack (Integer 1));
      prim1 (function Rib _ -> true_rib | _ -> false_rib);
      prim1 get_car;
      prim1 get_cdr;
      prim1 get_tag;
      prim2 (fun y x -> set_car x y; y);
      prim2 (fun y x -> set_cdr x y; y);
      prim2 (fun y x -> set_tag x y; y);
      prim2 (fun y x -> to_bool (rib_eq x y));
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> to_bool (a < b)
                        | _ -> invalid_arg "< arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a + b)
                        | _ -> invalid_arg "+ arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a - b)
                        | _ -> invalid_arg "- arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a * b)
                        | _ -> invalid_arg "* arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a / b)
                        | _ -> invalid_arg "quotient arguments must be Integers");
      prim0 (function () -> Integer (getchar ()));
      prim1 (function Integer ch -> Integer (putchar ch) | _ -> invalid_arg "putchar argument must be Integer");
      prim1 (function Integer status -> exit status | _ -> invalid_arg "exit argument must be Integer")
    |]
end

let get_byte =
  let input_stream = Stream.of_string input in
  function () -> (Stream.next input_stream |> int_of_char)

let get_code () =
  let x = (get_byte ()) - 35 in if x < 0 then 57 else x

let rec get_int n =
  let x = get_code () in
  let n = n * 46 in
  if x < 46 then n + x else get_int (n + x - 46)

let rec list_tail lst i =
  if i = 0 then lst else list_tail (get_cdr lst) (i - 1)

(* Build the initial symbol table *)
let symtbl = ref nil_rib
let _ =
  for n = get_int 0 downto 1 do
    symtbl := make_rib (make_rib false_rib
                          (make_rib nil_rib (Integer 0) (Integer 3))
                          (Integer 2))
                !symtbl (Integer 0)
  done;
  let accum = ref nil_rib
  and n = ref 0
  and in_loop = ref true in
  while !in_loop do
    let c = get_byte () in
    if c = 44 then begin
        let r1 = make_rib !accum (Integer !n) (Integer 3) in
        let r2 = make_rib false_rib r1 (Integer 2) in
        symtbl := make_rib r2 !symtbl (Integer 0);
        accum := nil_rib;
        n := 0
      end
    else if c = 59 then
      in_loop := false
    else begin
        accum := make_rib (Integer c) !accum (Integer 0);
        incr n
      end
  done;
  symtbl := make_rib (make_rib false_rib
                        (make_rib !accum (Integer !n) (Integer 3))
                        (Integer 2))
              !symtbl (Integer 0)

let symbol_ref n = list_tail !symtbl n |> get_car

let pc = ref nil_rib

(* Decode the RVM instructions *)
let _ =
  let codes = [| 20; 30; 0; 10; 11; 4 |]
  and in_loop = ref true
  and n = ref nil_rib in
  while !in_loop do
    let x = get_code ()
    and d = ref 0
    and op = ref 0
    and in_loop2 = ref true in
    n := Integer x;
    while !in_loop2 do
      d := codes.(!op);
      if int_val !n <= 2 + !d then
        in_loop2 := false
      else begin
          n := Integer ((int_val !n) - (!d + 3));
          incr op
        end
    done;
    if x > 90 then
      n := pop ()
    else begin
        if !op = 0 then begin
            stack := make_rib (Integer 0) !stack (Integer 0);
            incr op
          end;
        n := if int_val !n = !d then
               Integer (get_int 0)
             else if int_val !n >= !d then
               get_int ((int_val !n) - !d - 1) |> symbol_ref
             else if !op < 3 then
               int_val !n |> symbol_ref
             else
               !n;
        if 4 < !op then begin
            n := make_rib (make_rib !n (Integer 0) (pop ())) nil_rib (Integer 1);
            if not (is_rib !stack) then
              in_loop := false
            else
              op := 4
          end;
      end;
    if !in_loop then
      set_car !stack (make_rib (Integer (!op - 1)) !n (get_car !stack))
  done;
  pc := get_car !n |> get_tag

let get_opnd o =
  match o with
  | Rib _ -> o
  | Integer i -> list_tail !stack i

let get_cont () =
  let s = ref !stack in
  while not (is_rib (get_tag !s)) do
    s := get_cdr !s
  done;
  !s

let set_global v =
  set_car (get_car !symtbl) v;
  symtbl := (get_cdr !symtbl)

(* Execute the program *)
let _ =
  set_global (make_rib (Integer 0) !symtbl (Integer 1));
  set_global false_rib;
  set_global true_rib;
  set_global nil_rib;
  stack := make_rib (Integer 0) (Integer 0) (make_rib_of_ints 5 0 0);
  while true do
    if debug then start_step ();
    let o = ref (get_cdr !pc)
    and i = int_val (get_car !pc) in
    if i < 1 then begin (* jump/call *)
        if !tracing then begin
            (if is_rib (get_tag !pc) then "call " else "jump ") |> prerr_string;
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        o := get_opnd !o |> get_car;
        let c = ref (get_car !o) in
        if is_rib !c then begin
            let c2 = ref (make_rib (Integer 0) !o (Integer 0)) in
            let s2 = ref !c2
            and nargs = int_val (get_car !c) in
            for narg = nargs downto 1 do
              s2 := make_rib (pop ()) !s2 (Integer 0)
            done;
            if is_rib (get_tag !pc) then begin (* call *)
                set_car !c2 !stack;
                set_tag !c2 (get_tag !pc)
              end else begin (* jump *)
                let k = get_cont () in
                set_car !c2 (get_car k);
                set_tag !c2 (get_tag k)
              end;
            stack := !s2
          end else begin
            Primitives.primitives.(int_val !c) ();
            if is_rib (get_tag !pc) then (* call *)
              c := !pc
            else begin (* jump *)
                c := get_cont ();
                set_cdr !stack (get_car !c)
              end
          end;
        pc := get_tag !c
      end else if i < 2 then begin (* set *)
        if !tracing then begin
            prerr_string "set ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        set_car opnd (get_car !stack);
        stack := get_cdr !stack;
        pc := get_tag !pc
      end else if i < 3 then begin (* get *)
        if !tracing then begin
            prerr_string "get ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        push (get_car opnd);
        pc := get_tag !pc
      end else if i < 4 then begin (* const *)
        if !tracing then begin
            prerr_string "const ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        push !o;
        pc := get_tag !pc
      end else if i < 5 then begin (* if *)
        if !tracing then prerr_endline "if";
        pc := if pop () == false_rib then get_tag !pc else get_cdr !pc
      end else begin (* halt *)
        if !tracing then prerr_endline "halt";
        exit 0
      end
  done
