(* RVM code that prints HELLO! *)
let input = "R\'dnoc,radadc,?=<rahc,rorre,?naeloob,cc/llac,!tes-rotcev,rdaddc,?=>gnirts,etacnurt,raaddc,?orez,qmem,=<,dneppa-gnirts,?evitagen,nigeb,rotaremun,nim,mcl,gnirtsbus,regetni>-rahc,etouq,radddc,?>rahc,?=>rahc,xam,>,rddadc,rdadac,ypoc-gnirts,=,gnirts-ekam,fer-rotcev,qssa,radaac,raaadc,rotanimoned,?<rahc,rddaac,raaaac,!rdc-tes,rahc>-regetni,rdaaac,!tes,rotcev-ekam,roolf,gniliec,fi,oludom,dna,?evitisop,raddac,rahc-etirw,htgnel-rotcev,?=gnirts,!tes-gnirts,?qe,?regetni,rdaadc,rddddc,?=rahc,htgnel-gnirts,enifed,ro,adbmal,tel,?=<gnirts,dnuor,raadac,=>,!llif-gnirts,!llif-rotcev,dcg,?rotcev,rebmem,fer-gnirts,?<gnirts,hcae-rof,?erudecorp,redniamer,vmem,lave,vssa,gnirts>-rebmun,?ddo,pam,tixe,?>gnirts,gnirts>-lobmys,tsil>-rotcev,rebmun>-gnirts,tpxe,lobmys>-gnirts,cossa,esrever,!rac-tes,?neve,raadc,raaac,rdddac,rdaac,radc,raac,radac,?gnirts,rdadc,fer-tsil,lper,rdddc,raddc,dneppa,enilwen,rotcev>-tsil,?tcejbo-foe,sba,+,?lobmys,yalpsid,?llun,htgnel,etirw,daer,?lauqe,rahc-keep,tneitouq,rddac,,gnirts>-tsil,tsil>-gnirts,ton,,,rddc,,,,*,rdac,,,,rac,?riap,rahc-daer,<,-,rdc,snoc,,?vqe,,,,,;9$!T199l@YN@YE_@YHiU2@YH^{]$9$@YN@YEZ>^8N~YL^YD@YT8vCvR3y]>7#YU,^z!U,8TGi&:HiU1ai&kkz!U1:kw\'k!TA\'_*YTAaB_G^~F^{!T9\'^8T9YJlbB`^\'`~?_G_~F_|!TC8TI`^YT9ka_BaG`1YTCdBbAai$G`^~F_|!U.#`kn8:^~i$#`kn8:^~i$#`kn8:^~i$#`kn8:^~YT5Q^~?w)I^~?kJ^~YT5^z!U(#YU.a_l{!TI#a_k#k_k~?iU1_{!?1b1:VfBdbw)k~FBaG`^|!T>1V:h-w7k1Vf~?iU1fdAaaa^}(!TE*i&^z!TF*YTE`^{!TJ*YTFb`^|!T6*YTJca_wS2|!1#b`n8T>fAi&AbwU3awU3`8TCAea_`~YI_B`1ci$1cYT6APdwT4ABKcwT$GKa1cABKbwT$~?GKbwU8~FBa_~?wT4^1ci$1cN^1cNYTJYT6APgxPwU3wU3YTEYTF`wU3xN~FPbKa~FBa_~?xP^1ci%1cN^1cNYT6i$APdwS0^~FPbKa~FBa_~?wS0^8T>fPdK`G_`GK`~?xN^8?cBa_~?wT$^#YTIewT?#d~YGbYTGi&:ViU1PeYTAAAfi$i$akYF_nK`~?xO^1:HgZ,ecHfWdboKa_~?wS2^1YU(dYT9lbKbWa_~N?wS#_8T>fAi&AbwU3awU3`8TCAea_`~YI_B`1ci$1cYT6APdwT4ABKcwT$GKa1cABKbwT$~?GKbwU8~FBa_~?wT4^1ci$1cN^1cNYTJYT6APgxPwU3wU3YTEYTF`wU3xN~FPbKa~FBa_~?xP^1ci%1cN^1cNYT6i$APdwS0^~FPbKa~FBa_~?wS0^8T>fPdK`G_`GK`~?xN^8?cBa_~?wT$^#YTIewT?#d~YGbYTGi&:ViU1PeYTAAAfi$i$akYF_nK`~?xO^1:HgZ,ecHfWdboKa_~?wS2^1YU(dYT9lbKbWa_~N^~^?wS6^#cKan~?wSL^G_~F_#bYT9k``m~YI_|!T86_@M^{!N6uy!S-i6!;\'i$8;aB_@M^8;aB_@M^@MvS#~N?vS#_8;aB_@M^8;aB_@M^@MvS#~N^~^?vE^8;aB_@MvS;@MvS#~?t^8;aB_@MvS9@MvS#~?v0^8;aB_@MvS5@MvS#~?u^8;aB_@M^~S`G^~F^{!TN\'i$\'i$8TNB^@YEG^~F^@MvC~F^z!H8HZ<^8T8vS7vF~ZA^8EZ6^@MvF~ZF^8;i$T^~Z\'^8HZ7^~YI^6vL@YTNB^@YEG^@MvK~F^8T8vLvK~YG^8T8vS;vF~?i%^8T8vS-vF~S^z!E8H^6vE@Ri%T^@MvE~Z\'^z!TO8TO8T;~?u^\'^~Dk^Ey!T;8T;@E\'^8TO~?vR0^~D_vC\'iU5~YL^YBy!T78T7A`^8T7Aa^8T7Aat~?vS;^8T7Aav0~?vS9^8T7Aau~?vS5^E~?vS#^91_~?vE^\'i&~YL^Ez!T=*YT=^@E\'i&~NNDvD`*YT=^@E\'i&~NN^~^?vL_*YT=^@E\'i&~N^~^?vK^YBy!TP*YTP^YD\'i&@E~?vL^YT;y!8\'_88CCvRL_L`v3@E~i$\'_88CCvRL_L`v3@E~DvS.^~D_vS\'88CCvR,_L`v3@E~i$\'_88CCvRL_L`v3@E~i$\'_88CCvRL_L`v3@E~DvS.^~D_vS\'88CCvR,_L`v3@E~DvR<^~D_vR588CCvR%_L`v3@E~i$\'_88CCvRL_L`v3@E~i$\'_88CCvRL_L`v3@E~DvS.^~D_vS\'88CCvR,_L`v3@E~i$\'_88CCvRL_L`v3@E~i$\'_88CCvRL_L`v3@E~DvS.^~D_vS\'88CCvR,_L`v3@E~DvR<^~D_vR588CCvR%_L`v3@E~DvR/^~D_vR$YBz!D93`\'^~^^Z5^UAYT=^@E8>YT7i&@E~?vE^*Ai&YDwSL@E~?vJ^8MYD,Okk88k@E~?vP^YB@E~N?vRM_8MYD,Okk88k@E~?vP^YB@E~N^~^?vS?^\'i%@E~?vS;^\'i$@E~?vS-^YB@E~?vF^8TP@E~?vK^\'^~Dk^YT;y!B\'^!U7^Ey!TL\'^!U7iU6\'^~?iU5^!U7^z!.8TL^8TLYU+~?iU6^\'^~?iU5^iU7y!U7iU6!L(iU5^z!T/7%YT?\'_@YU-Qc^@YT@Jc^IIYT?i$zIIYT?i$z]B\'i$9BB`^@X$G_~F_{]:\'i&*Z:Ba_X$G_~F_{!TG#l`^{]AYT:l]H8T@YT<aI_^{!S58MYT<k^z!T.8U%b`J^|!SA9%`J^{!S,i2]6i3!M#oYF_^z]FYT:o]I8T@YT<aI_^{!SD8>YOi&T^z!T&8>YOT`T^{!U)8>a8U)AfZDbb`a_Cl`~Da_}\'!SN8U)i&b`^|!U#\'k\'iU5~F_\'l8U#BbB`\'l~D`^\'iU5~D__G`G^~F_~F^{!TD8U#T`T^{!T,8<ZC`^{]M8<Z8`^{]8-YTDa_k{]C-kYTD`^{!S+(kYTD`^{!SB8>YT<vC^z!S*8U%b`J^|]D9%`J^{!S$i2!=i3!>#nYF_^z]\'YT:n!S8i\'!SMi\'!SIjJ!T2iT\'!SJiSG!S<i-!S%i(!U\'\'_\'i$\'i$8U\'CCvR%`LbuB_~DvR/^~D_vR$G^~F^{!TM8U\'k^\'i$~YG^z]5\'i$,_k~^YTM^8TMB^~?vPG^\'i$~YG^T^z!TK\'^8TK_`~DakAb^YJCLu``vR%YAu^{]<8>YTKi&^8>AYTKi&C`kvP~Dk^z]4\'^5__~Z;`Z4YAm`L_^\'l~?k_{]Li\'!T+i\'!S3i\'!S4i\'!S=\'lz!T#i\'!SO5_YAZG``_YK`YK^\'k~?k_{!TB8TB_Z@__\'_~?k^{]G8TB`^8TB__~D__YK`YK^{!S18Jb^\'^~?DkbDk`\'k~?k^CL`a_YA`^{]@,LYAb``^{!K\'^,_k~Dk^z!SP\'_\'^~D`^{!SH\'^\'_~D`^{];8<Z/^z]/(LYAm`m^z!T%-k^z!S/-_kz!T)(k^z]J8<D`^{!T\'8<D__{!SG-__{!SCi(!S(8<YT5^z@YU/ki#!U4Ii#!U$\'^!U4AiU4^YU0^8U$Ia_\'^~YC`I^J_~F_{]38U$iU4^z]7i2!U0#m_i$z!IYT:m!U&\'`8U&Aca`Cl^~D_k|!T<8U&i&`^{]2\'i$92Ba_\'^~YCG__G_~F_{!S@j=]=\'i$9=Ba_\'^~?G__G_~F_{]E\'i$9EB`^\'_~YCG`^~F_{!T(j?]?\'i$9?B`^\'_~?G`^~F_{!TH\'^8THCl`B^~D`k{!U%90aYTH`^|]%0YTH`^{!U*\'_8U*AaG_B^~F^{]18U*i&^z!O\'_*YOaB_G^~F^{!F\'k8JYFB_l~F^z!G(i&^z!S&9#I^z!SK9#J^z!T-8PI^z!T*8PJ^z!SF9&I^z!T39&J^z!S\'9.I^z!S>9.J^z!S.8@J^z!SE9(I^z]K9(J^z!S;9+I^z!S?9+J^z!S79-I^z!S:9-J^z]#89I^z!P89J^z]&9*I^z].9*J^z](4J^z]+9)I^z]-9)J^z]*2J^z])3J^z],8@I^z!@4I^z!92I^z!43I^z!S9iU/]0iT@!+i2!0i3!*#k`^{!/YT:k!C\'i$\'i$\'i$\'i$8CJaJ_~YCIaI_~YCQaQ_~YT5`\'i$~?pQ_~YT5_\'^~^?`^{!S)i(!T08<_\'^~^?i%^z!<(i$^z!T:8T?\'i$(bQ^~YT5^zz!U2:nl:ki&vC!U6Cmk!U5Clk!\':lkl!):lkm!7:lkn!T?:lko!T5:lkp!3:lkq!2:lkr!::lks!T@:lkt!U/:lku!U-:lkv.!(:lkv/!-:lkv0!J:lkv1!,:lkv2!5:lkv3!A:lkv4!U+:lkv5!6:lkv6]9:lkv7y"

let debug = Sys.getenv_opt "RIBBIT_DEBUG" |> Option.is_some
let tracing = ref false
let step_count = ref 0
let start_tracing = ref 0
let next_stamp = ref 0

let _ = if debug then Printexc.record_backtrace true

module Rib = struct
  (* Rib (car, cdr, tag) *)
  type t = Rib of t ref * t ref * t ref | Integer of int

  let make_rib_of_ints a b c =
    Rib (ref (Integer a), ref (Integer b), ref (Integer c))
  let make_rib a b c = Rib (ref a, ref b, ref c)

  let is_rib = function Rib _ -> true | _ -> false
  let is_int = function Integer _ -> true | _ -> false

  let int_val = function Integer i -> i
                     | _ -> invalid_arg "int_val expects an Integer"
  let int_val_orelse i def =
    match i with
    |  Integer i -> i
    | _ -> def

  let rib_eq a b =
    match a, b with
    | Integer x, Integer y -> x = y
    | Rib _, Rib _ -> a == b
    | _ -> false

  let get_car = function Rib (car,_,_) -> !car
                       | _ -> invalid_arg "get_car expects a rib"
  let set_car rib newval =
    match rib with
    | Rib (car,_,_) -> car := newval
    | _ -> invalid_arg "set_car expects a rib"
  let get_cdr = function Rib (_,cdr,_) -> !cdr
                       | _ -> invalid_arg "get_cdr expects a rib"
  let set_cdr rib newval =
    match rib with
    | Rib (_,cdr,_) -> cdr := newval
    | _ -> invalid_arg "set_cdr expects a rib"
  let get_tag = function Rib (_,_,tag) -> !tag
                       | _ -> invalid_arg "get_tag expects a rib"
  let set_tag rib newval =
    match rib with
    | Rib (_,_,tag) -> tag := newval
    | _ -> invalid_arg "set_tag expects a rib"

  let false_rib = make_rib_of_ints 0 0 5
  let true_rib = make_rib_of_ints 0 0 5
  let nil_rib = make_rib_of_ints 0 0 5

  let to_bool = function true -> true_rib | false -> false_rib

  let write_to_buffer rib buf =
    let rec helper r =
      match r with
      | Integer i -> Printf.bprintf buf "%d" i
      | Rib _ when r == true_rib -> Buffer.add_string buf "#t"
      | Rib _ when r == false_rib -> Buffer.add_string buf "#f"
      | Rib _ when r == nil_rib -> Buffer.add_string buf "()"
      | Rib (car, cdr, tag) ->
         let obj = ref r in
         let typ = int_val_orelse !tag (-1) in
         if typ = 4 then begin
             Buffer.add_char buf '#';
             helper !car
           end else if typ = 0 then begin
             let n = ref 0 in
             Buffer.add_char buf '(';
             helper !car;
             let obj = ref !cdr in
             while is_rib !obj && int_val_orelse (get_tag !obj) (-1) = 0 do
               if !n > 4 then begin
                   Buffer.add_string buf " ...";
                   obj := nil_rib
                 end else begin
                   Buffer.add_char buf ' ';
                   helper (get_car !obj);
                   obj := get_cdr !obj;
                   incr n
                 end
             done;
             if not (!obj == nil_rib) then begin
                 Buffer.add_string buf " . ";
                 helper !obj
               end;
             Buffer.add_char buf ')'
           end else if typ = 1 then begin
             if is_rib !car then
               Printf.bprintf buf "#<procedure params=%d>" (int_val (get_car !car))
             else
               Printf.bprintf buf "#<primitive %d>" (int_val !car)
           end else if typ = 2 then begin
             obj := get_cdr !obj;
             if is_rib !obj && int_val (get_tag !obj) = 3 &&
                  int_val (get_cdr !obj) > 0 then begin
                 obj := get_car !obj;
                 while is_rib !obj && int_val (get_tag !obj) = 0 do
                   Buffer.add_char buf (get_car !obj |> int_val |> char_of_int);
                   obj := get_cdr !obj
                 done;
               end else begin
                 Buffer.add_string buf "#<symbol ";
                 helper !obj;
                 Buffer.add_char buf '>'
               end
           end else if typ = 3 then begin
             Buffer.add_char buf '"';
             obj := !car;
             while is_rib !obj && int_val (get_tag !obj) = 0 do
               begin
                 match (get_car !obj |> int_val |> char_of_int) with
                 | '\n' -> Buffer.add_string buf "\\n"
                 | '\r' -> Buffer.add_string buf "\\r"
                 | '\t' -> Buffer.add_string buf "\\t"
                 | '\\' -> Buffer.add_string buf "\\\\"
                 | '"' -> Buffer.add_string buf "\\\""
                 | c -> Buffer.add_char buf c
               end;
               obj := get_cdr !obj
             done;
             Buffer.add_char buf '"'
           end else begin
             Buffer.add_char buf '[';
             helper !car;
             Buffer.add_char buf ',';
             helper !cdr;
             Buffer.add_char  buf ',';
             helper !tag;
             Buffer.add_char buf ']'
           end in
    helper rib;
    buf

  let print_rib ?(out=stdout) rib =
    Buffer.create 16 |> write_to_buffer rib |> Buffer.output_buffer out
end

open Rib

let stack = ref (Integer 0)

let start_step () =
  incr step_count;
  if !step_count >= !start_tracing then tracing := true;
  if not !tracing then begin
      if !step_count >= !next_stamp then begin
          next_stamp := (float_of_int !next_stamp) *. 1.01 +. 1.0 |>  int_of_float;
          Printf.printf "@%d\n" !step_count;
        end
    end else begin
      let s = ref !stack in
      let buf = Buffer.create 80 in
      let sep = ref "" in
      Printf.bprintf buf "@%d STACK = (" !step_count;
      while is_rib !s && int_val_orelse (get_tag !s) (-1) = 0 do
        Buffer.add_string buf !sep;
        write_to_buffer (get_car !s) buf |> ignore;
        sep := " ";
        s := get_cdr !s
      done;
      Buffer.add_char buf ')';
      Buffer.output_buffer stdout buf;
      print_newline ();
      flush stdout
    end

let push x = stack := make_rib x !stack (Integer 0)
let pop () =
  match !stack with
  | Rib (car,cdr,_) ->
     stack := !cdr;
     !car
  | _ -> invalid_arg "Top of stack is not a rib"

module type PRIMITIVES = sig
  val primitives: (unit -> unit) array
end

module Primitives : PRIMITIVES = struct
  let prim0 f = function () -> f () |> push
  let prim1 f = function () -> pop () |> f |> push
  let prim2 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  f x y |> push
  let prim3 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  let z = pop () in
                  f x y z |> push

  let getchar () =
    try
      input_char stdin |> int_of_char
    with End_of_file -> -1

  let putchar c =
    char_of_int c |> print_char;
    flush stdout;
    c

  let primitives = [|
      prim3 (fun z y x -> make_rib x y z);
      prim1 (function x -> x);
      (function () -> pop () |> ignore);
      prim2 (fun y x -> y);
      prim1 (function x -> make_rib (get_car x) !stack (Integer 1));
      prim1 (function Rib _ -> true_rib | _ -> false_rib);
      prim1 get_car;
      prim1 get_cdr;
      prim1 get_tag;
      prim2 (fun y x -> set_car x y; y);
      prim2 (fun y x -> set_cdr x y; y);
      prim2 (fun y x -> set_tag x y; y);
      prim2 (fun y x -> to_bool (rib_eq x y));
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> to_bool (a < b)
                        | _ -> invalid_arg "< arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a + b)
                        | _ -> invalid_arg "+ arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a - b)
                        | _ -> invalid_arg "- arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a * b)
                        | _ -> invalid_arg "* arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a / b)
                        | _ -> invalid_arg "quotient arguments must be Integers");
      prim0 (function () -> Integer (getchar ()));
      prim1 (function Integer ch -> Integer (putchar ch) | _ -> invalid_arg "putchar argument must be Integer");
      prim1 (function Integer status -> exit status | _ -> invalid_arg "exit argument must be Integer")
    |]
end

let get_byte =
  let input_stream = Stream.of_string input in
  function () -> (Stream.next input_stream |> int_of_char)

let get_code () =
  let x = (get_byte ()) - 35 in if x < 0 then 57 else x

let rec get_int n =
  let x = get_code () in
  let n = n * 46 in
  if x < 46 then n + x else get_int (n + x - 46)

let rec list_tail lst i =
  if i = 0 then lst else list_tail (get_cdr lst) (i - 1)

(* Build the initial symbol table *)
let symtbl = ref nil_rib
let _ =
  for n = get_int 0 downto 1 do
    symtbl := make_rib (make_rib false_rib
                          (make_rib nil_rib (Integer 0) (Integer 3))
                          (Integer 2))
                !symtbl (Integer 0)
  done;
  let accum = ref nil_rib
  and n = ref 0
  and in_loop = ref true in
  while !in_loop do
    let c = get_byte () in
    if c = 44 then begin
        let r1 = make_rib !accum (Integer !n) (Integer 3) in
        let r2 = make_rib false_rib r1 (Integer 2) in
        symtbl := make_rib r2 !symtbl (Integer 0);
        accum := nil_rib;
        n := 0
      end
    else if c = 59 then
      in_loop := false
    else begin
        accum := make_rib (Integer c) !accum (Integer 0);
        incr n
      end
  done;
  symtbl := make_rib (make_rib false_rib
                        (make_rib !accum (Integer !n) (Integer 3))
                        (Integer 2))
              !symtbl (Integer 0)

let symbol_ref n = list_tail !symtbl n |> get_car

let pc = ref nil_rib

(* Decode the RVM instructions *)
let _ =
  let codes = [| 20; 30; 0; 10; 11; 4 |]
  and in_loop = ref true
  and n = ref nil_rib in
  while !in_loop do
    let x = get_code ()
    and d = ref 0
    and op = ref 0
    and in_loop2 = ref true in
    n := Integer x;
    while !in_loop2 do
      d := codes.(!op);
      if int_val !n <= 2 + !d then
        in_loop2 := false
      else begin
          n := Integer ((int_val !n) - (!d + 3));
          incr op
        end
    done;
    if x > 90 then
      n := pop ()
    else begin
        if !op = 0 then begin
            stack := make_rib (Integer 0) !stack (Integer 0);
            incr op
          end;
        n := if int_val !n = !d then
               Integer (get_int 0)
             else if int_val !n >= !d then
               get_int ((int_val !n) - !d - 1) |> symbol_ref
             else if !op < 3 then
               int_val !n |> symbol_ref
             else
               !n;
        if 4 < !op then begin
            n := make_rib (make_rib !n (Integer 0) (pop ())) nil_rib (Integer 1);
            if not (is_rib !stack) then
              in_loop := false
            else
              op := 4
          end;
      end;
    if !in_loop then
      set_car !stack (make_rib (Integer (!op - 1)) !n (get_car !stack))
  done;
  pc := get_car !n |> get_tag

let get_opnd o =
  match o with
  | Rib _ -> o
  | Integer i -> list_tail !stack i

let get_cont () =
  let s = ref !stack in
  while not (is_rib (get_tag !s)) do
    s := get_cdr !s
  done;
  !s

let set_global v =
  set_car (get_car !symtbl) v;
  symtbl := (get_cdr !symtbl)

(* Execute the program *)
let _ =
  set_global (make_rib (Integer 0) !symtbl (Integer 1));
  set_global false_rib;
  set_global true_rib;
  set_global nil_rib;
  stack := make_rib (Integer 0) (Integer 0) (make_rib_of_ints 5 0 0);
  while true do
    if debug then start_step ();
    let o = ref (get_cdr !pc)
    and i = int_val (get_car !pc) in
    if i < 1 then begin (* jump/call *)
        if !tracing then begin
            (if is_rib (get_tag !pc) then "call " else "jump ") |> prerr_string;
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        o := get_opnd !o |> get_car;
        let c = ref (get_car !o) in
        if is_rib !c then begin
            let c2 = ref (make_rib (Integer 0) !o (Integer 0)) in
            let s2 = ref !c2
            and nargs = int_val (get_car !c) in
            for narg = nargs downto 1 do
              s2 := make_rib (pop ()) !s2 (Integer 0)
            done;
            if is_rib (get_tag !pc) then begin (* call *)
                set_car !c2 !stack;
                set_tag !c2 (get_tag !pc)
              end else begin (* jump *)
                let k = get_cont () in
                set_car !c2 (get_car k);
                set_tag !c2 (get_tag k)
              end;
            stack := !s2
          end else begin
            Primitives.primitives.(int_val !c) ();
            if is_rib (get_tag !pc) then (* call *)
              c := !pc
            else begin (* jump *)
                c := get_cont ();
                set_cdr !stack (get_car !c)
              end
          end;
        pc := get_tag !c
      end else if i < 2 then begin (* set *)
        if !tracing then begin
            prerr_string "set ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        set_car opnd (get_car !stack);
        stack := get_cdr !stack;
        pc := get_tag !pc
      end else if i < 3 then begin (* get *)
        if !tracing then begin
            prerr_string "get ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        push (get_car opnd);
        pc := get_tag !pc
      end else if i < 4 then begin (* const *)
        if !tracing then begin
            prerr_string "const ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        push !o;
        pc := get_tag !pc
      end else if i < 5 then begin (* if *)
        if !tracing then prerr_endline "if";
        pc := if pop () == false_rib then get_tag !pc else get_cdr !pc
      end else begin (* halt *)
        if !tracing then prerr_endline "halt";
        exit 0
      end
  done
